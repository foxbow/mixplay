/* -1: configuration; 0: no update; 1: normal updates */
var doUpdate=-1;
var data=null;
var mpver=~~MPCOMM_VER~~;
var isstream=0;
var msglines=["","","","","","","","","","","","","","",""];
var msgpos=0;
var active=0;
var scrolls=[];

/*
 * pops up the current build ID
 */
function showInfo() {
	alert( "Running mixplayd version ~~MP_VERSION~~" );
}

/* 
 * check if a long text needs to be scrolled and then scroll into the
 * proper direction 
 */
function scrollToggle( ) {
	var to=1000;
	if (doUpdate == 0) return;
	for (var i = 0; i < scrolls.length; i++) {
		var element=scrolls[i].element;
		if( scrolls[i].offset.charAt(0) == '-' ) {
			if( element.style.right == scrolls[i].offset ) {
				element.style.right="0px";
				to=10000;
			}
			else {
				element.style.right = scrolls[i].offset;
				to=15000;
			}
		}
	}
	
	setTimeout( "scrollToggle()", to );
}

/*
 * enables scrolling on texts that are longer than the parent container 
 * and centers shorter texts 
 */
function setScrolls( ) {
	for( var i=0; i < scrolls.length; i++ ) {
		var scroll=scrolls[i];
		var element=scroll.element;
		element.style.left="auto";
		element.style.right="auto";
		var off_right=getComputedStyle(element).right;
		var right=parseInt(off_right,10);
		scroll.offset=off_right;
		if( off_right.charAt(0) == '-' ) {
			element.style.right = off_right;
			element.offsetHeight;
			element.style.transition = 'right 5s ease-in-out';
		}
		else {
			element.style.left=(right/2)+"px";
		}
	}
}

/*
 * sets up the scroller object 
 */
function initScroll(index,id) {
	if( scrolls[index] == undefined ) {
		var element=document.getElementById(id);
		var scroll={"id":id,"element":element,"offset":"0px"};
		scrolls[index]=scroll;
	}
}

/*
 * start scrollers onload - see HTML
 */
function initScrolls() {
	initScroll(0, 'prev');
	initScroll(1, 'title');
	initScroll(2, 'next');
}

/*
 * stop updates and make sure that error messages do not stack
 */
function fail( msg ) {
	if( doUpdate != 0 ) {
		doUpdate=0;
		/* pull main to front */
		toggleVisibility('5');
		alert( msg );
	}
}

/*
 * set profile to sanitized value
 */
function setProf() {
	var e=document.getElementById("profiles");
	var id=e.value;
	if( id != 0 ) {
		/* pull main to front */
		toggleVisibility('5');
		sendCMD( 0x06,id );
	}
	else {
		e.value=active;
	}
}

/*
 * toggle main UI tabs
 */
function toggleVisibility( element ) {
var e;
var b;
	for( i=0; i<6; i++ ) {
		e=document.getElementById( "extra"+i );
		b=document.getElementById( "show"+i );
		if( i == element ) {
			if( i == '3' ) { 
				b.value="\u2630 Messages"
			}
			b.style.backgroundColor='#ddd';
			e.style.display='block';
		}
		else {
			e.style.display='none';
			b.style.backgroundColor='#fff';
		}
	}
}

/**
 * toggle search result tabs
 */
function toggleResults( element ) {
	for( i=0; i<3; i++ ) {
		e=document.getElementById( "search"+i );
		b=document.getElementById( "ctrl"+i );
		if( i == element ) {
			b.style.backgroundColor='#ddd';
			e.style.display='block';
		}
		else {
			b.style.backgroundColor='#fff';
			e.style.display='none';
		}
	}
}

/*
 * stop the server - this should really not be here =)
 */
function killServer() {
	if( confirm("Do you really want to stop the Server?") ) {
		/* pull main to front */
		toggleVisibility('5');
		sendCMD(0x11);
		doUpdate=0;
	}
}

/* 
 * add a line of text to the message pane. Acts as ringbuffer
 */
function addText(text) {
	var line="";
	var numlines=15;
	e=document.getElementById('extra3');

	if( msgpos < numlines ) {
		msglines[msgpos]=text;
		msgpos++;
	}
	else {
		for( i=0; i<numlines-1; i++ ) {
			msglines[i]=msglines[i+1];
		}
		msglines[numlines-1]=text;
	}

	for( i=0; i<numlines; i++ ) {
		line+=msglines[i]+"<br>\n";
	}
	e.innerHTML=line;

	f=document.getElementById('show3');
	if( e.style.display=='none') {
		f.value="\u2630 Messages *"
	}
}

/*
 * send a command with optional argument to the server
 */
function sendCMD( cmd, arg="" ) {
	var xmlhttp=new XMLHttpRequest();
	var code=Number(cmd).toString(16);
	while (code.length < 4) {
		code = "0" + code;
	}

	/* filter out commands that make no sense in stream */ 
	if( ( isstream ) && (	
		( code == '0002' ) ||
		( code == '0003' ) ||  
		( code == '0005' ) ||
		( code == '000f' ) ||  
		( code == '0010' ) ) ) return;
		
	/* these commands should pull main to front */
	if( ( code == '0003' ) ||
	    ( code == '010c' ) ) toggleVisibility('5');

	/* These command should pull the messages to front */
	if( ( code == '0008' ) ||
	    ( code == '0012' ) ) toggleVisibility('3');

	xmlhttp.onreadystatechange=function() {
		if ( xmlhttp.readyState==4  ) {
			switch( xmlhttp.status ) {
			case 0:
				fail( "CMD Error: connection lost!" );
				break;
			case 204:
				break;
			case 503:
				alert( "Sorry, we're busy!" );
				break;
			default: 
				fail( "Received Error "+xmlhttp.status+" after sending 0x"+code );
			}
		}
	}

	if( arg != "" ) {
		xmlhttp.open("GET", "/cmd/"+code+"?"+arg, true);
	}
	else {
		xmlhttp.open("GET", "/cmd/"+code, true);
	}
	xmlhttp.send();
}

/*
 * use scrollwheel to control volume
 */
function volWheel( e ) {
	if( e.deltaY < 0 ) {
		sendCMD( 0x0d);
	}
	else if( e.deltaY > 0 ) {
		sendCMD( 0x0e );
	}
}

/*
 * change text in an element
 */
function setElement( e, val ) {
	document.getElementById( e ).innerHTML=val;
}

/*
 * show/hide a <div>
 */
function setVisible( e, i ) {
	if( i == 0 ) {
		document.getElementById( e ).style.display='none';
	}
	else {
		document.getElementById( e ).style.display='block';
	}
}

/*
 * show/hide an inline element
 */
function enableTab( e, i ) {
	if( i == 0 ) {
		document.getElementById( e ).style.display='none';
	}
	else {
		document.getElementById( e ).style.display='inline';
	}
}

/*
 * get current status from the server and update the UI elements with the data
 * handles different types of status replies
 */
function updateUI( ){
	var e;
	var xmlhttp=new XMLHttpRequest();
	xmlhttp.onreadystatechange=function() {
		if (xmlhttp.readyState==4 ) {
			if( xmlhttp.status==200 ) {
				data=JSON.parse(xmlhttp.responseText);
				if( data !== undefined ) {
					if( data.version != mpver ) {
						fail( "Version clash, expected "+mpver+" and got "+data.version );
						return;
					}
					/* full update */
					if( data.type == 3 ) {
						document.title=data.current.artist+" - "+data.current.title;
						setElement( 'title', data.current.title );
						setElement( 'prev', data.prev.artist+" - "+data.prev.title );
						setElement( 'artist', data.current.artist );
						setElement( 'album', data.current.album );
						setElement( 'genre', data.current.genre );
						if( data.next.length > 0 ) {
							setElement( 'next', data.next[0].artist+" - "+data.next[0].title );
							e=document.getElementById('extra4');
							e.innerHTML="<p class='cmd' onclick='sendCMD( 0x0002 )'>"+data.prev.artist+" - "+data.prev.title+"</p>";							
							e.innerHTML+="<p class='cmd' style='background-color: #ddd;' ><em>"+data.current.artist+" - "+data.current.title+"</em></p>";
							for( i=0; i<data.next.length; i++ ) {
								e.innerHTML+="<p class='cmd' onclick='sendCMD( 0x0003, "+(i+1)+")'>"+data.next[i].artist+" - "+data.next[i].title+"</p>";
							}
						}
						else {
							setElement( 'next', "- - -" );
						}
						if( data.current.flags & 1 )  {
							document.getElementById( 'fav' ).disabled=true;
						}
						else {
							document.getElementById( 'fav' ).disabled=false;
						}
						setScrolls();
					}

					/* search results */
					else if( data.type == 4 ) {
						/* rather use sendArg() than <a href> tags! */
						e=document.getElementById('search0');
						e.style.display='block';
						if( data.titles.length > 0 ) {
							e.innerHTML="<a href='/cmd/010c?0'>Play all</a><br/>";
							for( i=0; i<data.titles.length; i++ ) {
								e.innerHTML+="<p class='cmd' onclick='sendCMD( 0x010c, "+data.titles[i].key+")'>"+data.titles[i].artist+" - "+data.titles[i].title+"</p>"
							}
						}
						else {
							e.innerHTML="<em>Nothing found!</em>";
						}
						e=document.getElementById('search1');
						e.style.display='none';
						if( data.artists.length > 0 ) {
							e.innerHTML="";
							for( i=0; i<data.artists.length; i++ ) {
								e.innerHTML+="<p class='cmd' onclick='sendCMD( 0x0213, \""+data.artists[i]+"\")'>"+data.artists[i]+"</p>"
							}
						}
						else {
							e.innerHTML="<em>No artists found!</em>";
						}
						e=document.getElementById('search2');
						e.style.display='none';
						if( data.albums.length > 0 ) {
							e.innerHTML="";
							for( i=0; i<data.albums.length; i++ ) {
								e.innerHTML+="<p class='cmd' onclick='sendCMD( 0x0413, \""+data.albums[i]+"\")'>"+data.albart[i]+" - "+data.albums[i]+"</p>"
							}
						}
						else {
							e.innerHTML="<em>No albums found!</em>";
						}
					}

					/* standdard update */
					isstream=data.playstream;

					setVisible( 'prev', !isstream );
					setVisible( 'ctrl', !isstream );
					setVisible( 'playstr', isstream );
					setVisible( 'playpack', !isstream );
					enableTab( 'show0', !isstream );
					if( isstream ) {
						setElement( 'splaytime', data.playtime );
					}
					else {
						setElement( 'playtime', data.playtime );
						setElement( 'remtime', data.remtime );
						document.getElementById( 'progress' ).value=data.percent;
					}

					if( active != data.active ) {
						active=data.active;
						setActive( active );
					}
					if( data.status == 0 ) {
						document.getElementById('current').style.backgroundColor="#ddd";
					}
					else {
						document.getElementById('current').style.backgroundColor="#daa";
					}

					document.getElementById( 'vol' ).value=data.volume;
					if( ( data.msg != "" ) && ( data.msg != "Done." ) ) {
						addText(data.msg);
					}
				}
			}
			else if( xmlhttp.status == 0 ) {
				fail( "Update Error: connection lost!" );
			}
			else {
				fail( "Received Error "+xmlhttp.status+" after sending 0x"+code );
			}

			if( doUpdate != 0 ) {
				setTimeout("updateUI()",333);
			}
			else {
				document.open();
      			document.write("<h1>Server disconnected!</h1>");
      			document.close();
			}
		}
	}

	if( doUpdate == -1 ) {
		setTimeout("getConfig()",333);
		doUpdate=1;
	}

	xmlhttp.open("GET", "/status", true);
	xmlhttp.send();
}

/*
 * shows the current profile/channel in the profile select dropdown
 */ 
function setActive( id ) {
	var s=document.getElementById("profiles");
	s.value=id;
}

/*
 * gets the basic configuration of the server
 * this should only happen once at start
 */
function getConfig() {
	var xmlhttp=new XMLHttpRequest();
	xmlhttp.onreadystatechange=function() {
		if (xmlhttp.readyState==4 ) {
			if( xmlhttp.status==200 ) {
				data=JSON.parse(xmlhttp.responseText);
				if( data !== undefined ) {
					if( data.version != mpver ) {
						fail( "Version clash, expected "+mpver+" and got "+data.version );
						return;
					}
					if( data.type == 2 ) {
						var s=document.getElementById("profiles");
						s.options.length=0;
						for(i=0; i<data.config.profiles; i++) {
							s.options[s.options.length] = new Option(data.config.profile[i],i+1);
						}
						s.options[s.options.length] = new Option("None",0);
						for(i=0; i<data.config.streams; i++) {
							s.options[s.options.length] = new Option(data.config.sname[i],-(i+1));
						}
						active=0;
					}
					else {
						fail( "Received reply of type "+data.type+" for config!" );
					}
				}
				else {
					fail( "Received no Data for config!" );
				}
			}
			else {
				fail( "Received Error "+xmlhttp.status+" trying to get config" );
			}
		}
	}

	xmlhttp.open("GET", "/config", true);
	xmlhttp.send();
}

/*
 * set volume to a fixed value
 */
function setVolume( vol ) {
	sendCMD( 0x15, vol );
}

/*
 * send command with range info (FAV/DNP)
 */
function sendRange( cmd, term="" ) {
	var e=document.getElementById('range');
	if( term != "" ) {
		e=document.getElementById('srange');
	}
	var range=e.options[e.selectedIndex].value;
	if( isstream ) return;
	cmd|=range;
	sendCMD( cmd, term );
}

/*
 * send command with argument set in the 'text' element (Search)
 */
function sendArg( cmd ) {
	if( isstream ) return;
	var term=document.getElementById('text').value;
	if( term.length > 1 ) {
		sendRange( cmd, term, 1 );
	}
	else {
		alert("Need at least two letters!");
	}
}

/*
 * creates a new profile or loads a channel
 */
function createLoad() {
	var term=document.getElementById('ptext').value;
	var asking="";
	if( term.length < 3 ) {
		alert("Need at least two letters!");
	}
	else {
		if( term.toLowerCase().startsWith("http") ) {
			sendCMD( 0x17, term );
		}
		else {
			if( isstream ) {
				asking="Add current stream as channel "+term+" ?"
			}
			else {
				asking="Create new profile "+term+" ?"
			}
			if( confirm( asking ) ) {
				sendCMD( 0x16, term );
				doUpdate=-1;
			}
		}
		/* pull main to front */
		toggleVisibility('5');
	}
}

/*
 * removes the current profile
 */
function remProf() {
	var id=document.getElementById("profiles").value;
	if( id != 0 ) {
		if( confirm( "Remove Profile #"+id+"?" ) ) {
			sendCMD( 0x18,id );
			doUpdate=-1;
		}
	}

}

/*
 * download a title by key (0=current)
 */
function download(key=0) {
	window.location="/title/"+key;
}

/* 
 * start the UI update thread loops
 */
updateUI();
scrollToggle();
